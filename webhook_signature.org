#+title: Webhook signature
#+author: Cesar Gimenes
#+EMAIL:  cesar.gimenes@nox.trading
#+DESCRIPTION: This document describes how webhooks issued by NoxPay are signed.
#+KEYWORDS:  gateway,API,test,webhook,signature
#+LANGUAGE:  en
#+latex_class: article
#+latex_class_options: [a4paper,10pt,final]
#+LATEX_HEADER: \usepackage{subcaption}

#+LATEX_HEADER: \usepackage[table]{xcolor}
#+LATEX_HEADER: \usepackage[margin=0.9in,bmargin=1.0in,tmargin=1.0in]{geometry}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{bookman}
#+LaTeX_HEADER: \newcommand{\point}[1]{\noindent \textbf{#1}}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \parindent = 0em
#+LaTeX_HEADER: \setlength\parskip{.5\baselineskip}
#+LaTeX_HEADER: \usepackage[latin1]{inputenc}
#+OPTIONS:   H:3 num:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t ^:nil _:nil
#+OPTIONS:   H:3 num:3
#+STARTUP:   showall
#+STARTUP:   align
#+LaTeX_HEADER: \usepackage[latin1]{inputenc}

* Introduction

When NoxPay sends a call to a webhook, this call is signed so that the call destination can validate the content transmitted and thus guarantee the validity and authorship of the data.

* Where is the signature sent

The signature is sent in the header of the call, in the fields X-Signature and noxpay-sign.

#+begin_http
X-Signature: signature
noxpay-sign: signature
#+end_http

* How to validate the signature

The signature is generated by concatenating the key with the call's content and applying the SHA256 hash algorithm to the result, which is base64 encoded for transmission.

Python exemple:
#+begin_src python
import base64
import hashlib

def validate_signature(plaintext, key, signature):
    content = key.encode() + plaintext
    hashed = hashlib.sha256(content).digest()
    expected_signature = base64.b64encode(hashed).decode()
    return signature == expected_signature
#+end_src

Golang Example:
#+begin_src golang
import (
    "encoding/base64"
    "crypto/sha256"
)

func validateSignature(plaintext []byte, key string, signature string) bool {
    content := key + string(plaintext)
    bcontent := []byte(content)

    hashed := sha256.Sum256(bcontent)
    expectedSignature := base64.StdEncoding.EncodeToString(hashed[:])

    return signature == expectedSignature
}
#+end_src

